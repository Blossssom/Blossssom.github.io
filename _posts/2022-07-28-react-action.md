---

layout: post

title: 22 / 07 / 28 My TIL [React는 어떻게 동작할까]

subtitle: SEB TIL

categories: coding

tags: [React]

---
<aside>
우선 리액트는 사용자 인터페이스 구축을 위한 라이브러리 이며 Component의 개념을 핵심으로 한다는 사실을 잊지말자.

</aside>

바닐라 컴포넌트를 처음 구현하며 맨붕이 왔던 가장 큰 이유가 위와 같이 리액트가 무엇인가? 어떻게 동작하는가? 를 모르고 있었기 때문이었다고 생각한다. 

그저 어떤 hook을 써야 기능이 완성되는지만 신경을 쓰다보니 더 중요한 핵심을 놓치고 있었다.

리액트가 어떻게 동작하는지, 지금까지 놓치고 있었던건 무엇인지 차근차근 알아보며 학습해보자.

## React는 무엇을 하는가?

react는 컴포넌트를 관리하고 상태를 관리하며, 다른 객체의 상태를 파악해 컴포넌트의 변경을 위해 전후 상태를 확인하는 라이브러리이다. 

이러한 components의 관리와 상태 관리는 사용자 인터페이스의 효과적인 구성을 가능케한다.

결론적으로 React는 웹에 대해서 관여하지 않는다. 브라우저에 대해 알지못하며 Component 내부에 HTML Tag가 있는지도 중요하지 않으며 사용자의 화면에 무언가를 표현하는 역할은 모두 `React Dom`  의 몫이다. 

진짜 우직하게 Components 만 신경쓴다.

## React Dom

그러면 ReactDom 이라는 것은 무엇일까? 우선 React는 변경된 내용과 화면에 표시되어야 할 모든 정보를 사용중인 인터페이스에 전달하는데, 여기선 ReactDom이 그 대상이다. 

지금까지를 정리해보면 React는 자신의 역할에 따라 이전상태와 비교해 변경사항을 관리하여 화면에 새로운 사항을 표시해야하는지 확인하여 ReactDom에게 전달하고 변경된 상태에 따라 실제 DOM (Real Dom)에 관여하는 역할은 ReactDom이 진행한다.

보통 React의 Component 상태가 변경되면 재실행되며 브라우저에서 리렌더링 된다고 알고 있지만 모두 리렌더링 되지는 않는다. 생각해보면 한부분이 변할 때 마다 전부 렌더링을 다시 하는건 엄청난 낭비다.

그러면 비교는 어떻게 이뤄지는가?

## Virtual Dom

최종적으로 React의 역할은 가상 DOM 즉, VirtualDom을 사용하는 것이다. 이 VirtualDom은 앱이 마지막에 만들어내는 컴포넌트 Tree를 결정한다. 

각각의 하위 트리를 가진 컴포넌트들은 JSX 코드를 반환하는데, 이를 가상 DOM의 최종 모양으로 사용한다. 따라서 상태의 변경에 따라 새로운 가상 DOM을 그리고 이전의 가상DOM과 변경 이후의 가상DOM의 차이를 비교해 RealDom에서 변경을 수행할 수 있는 최선의 방법을 계산한다.

이러한 비교 과정에서 가상DOM의 역할이 두드러지는데 가상 DOM은 가상의 UI를 메모리에 유지시키고 가상DOM 간의 비교를 수행하는데, 실제 DOM을 조작하는 것이 아니기 때문에 훨씬 가볍고 빠르게 진행된다. 

이를 통해 RealDom을 변경하는 조작방법을 ReactDom에게 전달하게 되며 변경 부분에 대해서만 리렌더링이 이뤄진다.

<aside>
여기서 중요한 부분은 컴포넌트의 상태 변화로 인해 재평가가 이뤄진다해서 DOM의 리렌더링이 이뤄진다는게 아니라는 점이다.

계속 설명했듯이 DOM은 VirtualDom에서 비교된 결과에 따라 업데이트된다.

</aside>

 

## Virtual Dom Diffing

![Untitled](/post-img/v-dom-1.png)

위와 같이 이전 결과와 변경 후 결과를 비교해 변경되는 부분에 대해서만 변경이 일어나며 다른 부분은 건드리지 않는다.

결론적으로 메모리에 저장된 가상의 UI를 통한 비교적 가벼운 상태 비교를 거쳐 실제 변화가 이뤄져야할 부분만 업데이트 되기 때문에 보다 빠르고 가벼운 작업이 될 수 있는 것이다.

![Untitled](/post-img/v-dom-2.png)

위 그림은 VirtualDom의 형태로 추상화된 JS 객체의 형태를 가지고 있다.

```jsx
const vDom = {
	tagName: "html",
	children: [
		{ tagName: "head" },
		{ tagName: "body",
			children: [
				tagName: "ul",
				attributes: { "class": "list"},
				children: [
					{
						tagName: "li",
						attributes: { "class": "list_item" },
						textContent: "List item"
					}
				]
			]
		}
	]
}
```

JS 객체로 표현하면 다음과 같을 것이고 실제 DOM과 마찬가지로 가상 DOM 또한 HTML 문서 객체를 기반으로 하기 때문에 실제 DOM을 건드리지 않고도 필요한 만큼 자유롭게 조작할 수 있다.

## React Diffing Algorithm

React가 가상 DOM을 비교하고 변경된 새로운 가상 DOM 트리에 부합하도록 기존 UI를 변경하기 위해서 효율적인 갱신 방법이 필요했다. 즉, 하나의 트리를 다른 트리로 변형 시키는 가장 효율적인 방식을 알아내야했는데 그 방식의 복잡도가 O(n^3) 이었다.

만약 이 알고리즘을 대입한다면 Element의 양에 따라 기하급수적인 연산이 필요하다. 따라서 React는 두 가지 가정을 가지고 O(n) 시간복잡도의 새로운 휴리스틱 알고리즘(Heuristic Algorithm) 을 구현해 낸다.

위에서 말한 두 가지 가정은 다음과 같다.

1. 각기 서로 다른 두 요소는 다른 트리를 구착할 것이다.
2. 개발자가 제공하는 `key` 프로퍼티를 활용해 여러번 렌더링을 거쳐도 변경되지 않아야 하는 자식 요소가 무엇인지 알아낼 수 있을 것이다.

실제 이 두 가정은 거의 모든 실제 사용 사례에 들어맞으며, 여기서 React는 비교 알고리즘(Diffing Algorithm)을 사용한다.

## React의 DOM Tree 탐색 방법

React는 기존의 가상 DOM트리와 변경된 가상 DOM트리를 비교하기 위해 트리의 레벨순서를 순회하며 탐색한다. 즉, 일종의 너비 우선 탐색(BFS)를 사용해 비교하는 것이다.

![Untitled](/post-img/v-dom-3.png)

### 다른 타입의 DOM element의 경우

그런데 생각해보면 DOM 트리는 HTML 태그의 규칙에 따라 자식과 부모의 관계가 한정적으로 이뤄진다. 예를 들어 `<ul>` 태그의 자식으로 `<li>` 가 반드시 와야 한다거나 `<p>` 내부에 중복의 `<p>`  태그를 쓰지 못하는것 처럼 지켜야할 규칙이 있기 때문에 부모 태그가 달라질 경우 React는 이전 트리를 버리고 새로운 트리를 구축한다.

```jsx
<div>
	<Counter />
</div>

//부모 태그가 div에서 span으로 바뀝니다.
<span>
	<Counter />
</span>
```

이처럼 부모 태그가 바뀔 경우 React는 기존 트리를 버리고 새로운 트리를 구축하기 때문에 이전의 DOM 노드들은 전부 파괴된다. 위 처럼 컴포넌트의 부모 태그가 바뀌면 새로운 컴포넌트가 실행되고, 기존의 컴포넌트가 해제(Unmount) 되기 떄문에 기존의 State 또한 파괴된다.

### 같은 타입의 DOM element의 경우

위와 반대로 타입이 바뀌지 않는다면 React는 최소한의 렌더링을 위해 변경사항만 업데이트 한다. 지금까지 알아본 가상DOM으로 인해 가능한 것이다.

업데이트할 내용이 있다면 virtualDOM 내부의 프로퍼티만 수정하고 모든 노드에 걸쳐 업데이트가 마무리되면 단 한번 실제 DOM으로 렌더링을 시도한다.

```jsx
//className이 before인 컴포넌트
<div style={{color: 'red', fontWeight: 'bold"}} title="stuff" />

//className이 after인 컴포넌트
<div style={{color: 'green', fontWeight: 'bold"}} title="stuff" />
```

두 element에 대해 React는 정확히 `color` 스타일만 바뀐것을 알아채고 해당 변경 프로퍼티만 수정한다. 이렇게 하나의 DOM 노드 처리를 마무리한 뒤 React는 나머지 자식들을 순차적으로 순회하며 차이가 발견될 때마다 변경하는데 이를 **재귀적으로 처리**한다고 표현한다.

### 자식 Element의 재귀적 처리

```jsx
<ul>
  <li>first</li>
  <li>second</li>
</ul>

//자식 엘리먼트의 끝에 새로운 자식 엘리먼트를 추가했습니다.
<ul>
  <li>first</li>
  <li>second</li>
  <li>third</li>
</ul>
```

위와 같은 element의 변경이 일어났다고 했을 때 React는 기존 DOM과 새로운 DOM을 비교하기 위해 자식 노드를 위에서 아래로 순차적으로 비교해간다.

이 동작 방식에 대해 고민하지 않고 리스트의 처음 부분에 element를 삽입하게 되면 순차적 추가에 비해 나쁜 성능을 내게 된다. 

```jsx
<ul>
  <li>Duke</li>
  <li>Villanova</li>
</ul>

//자식 엘리먼트를 처음에 추가합니다.
<ul>
  <li>Connecticut</li>
  <li>Duke</li>
  <li>Villanova</li>
</ul>
```

위와 같이 처음부분에 변경사항이 나타날 경우 위에서 아래로 비교를 진행하기 때문에 React는 첫 비교에 따라 리스트에 전체가 바뀌었다고 판단하고 기존과 같은 두 자식 노드까지 새롭게 렌더링한다.

이 문제를 해결하기 위해 React가 항상 `key` 속성을 넣으라며 불같이 화를 내는것이다. 독립적인 key 속성을 통해 기존 element의 key와 새로운 element의 key를 비교할 수 있기 때문에 React가 정확하게 변경된 부분을 파악할 수 있다.

만약 유니크한 값이 없을 경우 최후의 수단으로 index를 key로 사용할 수 있지만 배열이 변경되거나 새로 정렬되어도 index는 유지되기 때문에 React는 배열의 전체가 바뀌었다고 판단해 새로운 DOM 트리를 구축할 것이다.

<aside>
정말 어쩔 수 없는 경우라도 Read 목적의 element에만 사용하도록 하자.

</aside>

---
<br><br>
## 마무리

강의를 보다 의문점이 들어 하나하나 찾아보고, 공식문서도 보다보니 시간이 굉장히 오래걸렸다. 여러 상황에 대해 생각도하며 전체적인 그림도 파악해야해서 아직 완벽하게 설명할 순 없지만 반복적으로 다시보고 코드를 작성할 때 마다 생각하며 내것으로 만들어야한다.
