---

layout: post

title: 22 / 08 / 03 My TIL [Optimization]

subtitle: SEB TIL

categories: coding

tags: [React]

---
# Optimization (최적화)

<aside>
💡 최적화란 주어진 상황에서 원하는 가장 알맞은 결과를 얻을 수 있도록 처리하는 과정을 뜻하며 허용된 자원의 한계 내에서 주어진 요구사항을 만족시켜 최선의 결과를 얻는 과정이다. 

즉, 주어진 조건으로 최대 효율을 낼 수 있도록 하는 것을 의미한다.

CS 측면에서의 최적화는 가능한 적은 리소스로 가능한 빠르게 원하는 결과를 도출하는 것을 의미하며 알고리즘을 학습하는 이유가 이에 해당한다.

그렇다면 웹 개발 측면에서 특히, Front-end 측면에서 최적화는 무엇을 의미할까? 당연히 주어진 조건에서 최대한 빠르게 UI를 표시하는 것이다. 이제 최적화의 필요성을 살펴보고 최적화의 방법에 대해서도 살펴보자.

</aside>

## 최적화의 필요성 & 효과

### 1. 이탈률 감소

웹에서 최적화가 되어있지 않다는 의미는 페이지 로딩의 속도가 현저히 떨어진다는 의미로 UX 측면에서 살펴봤
이 사용자의 이탈률은 페이지 로딩 속도와 비례로 증가한다.

따라서 웹 페이지의 최적화를 통해 사용자의 이탈률을 줄일 수 있다는 의미로 최적화의 필요성을 엿볼 수 있다. 

### 2. 전환율 증가

위에서 설명한 이탈률의 감소는 자연스럽게 전환율의 증가로 이어진다. 전환율이란 사용자 중 회원가입, 상품 구매, 게시글 조회, 다운로드 등의 행위를 한 방문자의 비율을 뜻하며 실제 서비스의 사용자를 나타내기 때문에 사업적으로 중요한 지표에 해당한다.

### 3. 수익 증대

수익 증대 또한 위에서 설명한 개념의 연쇄효과로 전환율이 높아져 서비스 사용자가 높아지면 판매, 구독 등의 동작으로 이어지기 때문에 최적화는 수익 증대에도 효과를 미친다. 실제로 로딩 속도가 1초 빨라졌을 때 아마존은 판매량 1%, 구글 검색량은 0.2%, 월마트의 전환율은 2% 증가했다고 하니 효과가 상당한 듯 하다.

### 4. UX 향상

사실 웹 개발의 최적화는 UX 향상으로 전부 이어진다고 볼 수도 있다. 페이지 로딩 속도는 사용자 경험에 큰 부분을 차지하기 때문에 최적화가 UX 향상으로 이어지는 것은 당연할 것이다. 

## Optimization 기법

<aside>
💡 최적화의 필요성과 개념에 대해 알아봤으니 실제로 어떠한 방식으로 최적화를 적용하는지 알아보자.

</aside>

### HTML의 최적화

1. DOM Tree 가볍게 만들기

```html
// 수정 전
<div>
	<ol>
		<li> 첫 번째 </li>
		<li> 두 번째 </li>
		<li> 세 번째 </li>
	</ol>
</div>

// 수정 후 : 불필요한 div 요소 제거
<ol>
	<li> 첫 번째 </li>
	<li> 두 번째 </li>
	<li> 세 번째 </li>
</ol>
```

웹 페이지의 디자인, 스타일을 위해서 사용한 태그의 경우는 어쩔 수 없는 부분도 있지만 가능한 불필요한 요소를 제거하는 것이 기본적인 최적화 방식이다. DOM의 깊이가 깊을 수록 DOM Tree의 복잡도는 올라가기 때문에 불필요한 태그는 최소화하는 것을 지향해야한다.

1. inline style 사용하지 않기

```html
//수정 전
<div style="margin: 10px;"> 마진 10px </div>
<div style="margin: 10px;"> 이것도 마진 10px </div>

//수정 후 : class와 CSS로 대체
<div class="margin10"> 마진 10px </div>
<div class="margin10"> 이것도 마진 10px </div>

.margin10 {
	margin: 10px;
}
```

인라인 스타일은 개별 요소에 스타일을 적용하기 때문에 스타일의 중복이 발생할 수 있다. 이로인해 파일의 크기가 증가하는 것은 물론 가독성을 떨어뜨려 사용을 지양해야한다. 애초에 인라인 스타일의 경우 웹 표준에 맞지않기 때문에 더더욱 사용하지 않는 것이 좋다.

### CSS의 최적화

1. CSS 또한 HTML과 마찬가지로 불필요한 코드를 제거하는 것이 최우선이다. CSS파일의 모든 코드 분석이 끝난 후 CSSOM 트리가 생성되기 때문에 CSS 크기에 따라 트리의 완성 속도가 달라진다. 

1. 간결한 셀렉터 사용하기

```html
// 복잡한 CSS 셀렉터 예시
.cart_page .cart_item #firstItem { ... }

// 필요한 경우에는 어쩔 수 없지만, 가능한 한 간결하게 작성해줍니다.
.cart_item { ... }
```

복잡한 셀렉터의 경우 더 많은 연산을 필요로 하기 때문에 최대한 간결한 셀렉터를 사용하는 것이 좋다.

### 리소스 로딩의 최적화

```html
// CSS 파일은 HTML 파일 상단의 head 요소 안에서 불러오는 것이 좋습니다.
<head>
	<link href="style.css" rel="stylesheet" />
</head>
<body>
	<div>...</div>
	...

	// JavsScript 파일은 body 요소가 닫히기 직전에 작성하는 것이 가장 좋습니다. 
	<script src="script.js" type="text/javascript"></script>
</body>
```

CSS는 가능한 문서의 최상단에 배치하는 것이 좋은데, DOM의 경우 코드를 한 줄씩 읽어나가며 Tree를 구성하지만 CSSOM의 경우 CSS 파일을 모두 해석해야 구성할 수 있다. 따라서 CSS를 최상단에 배치해 CSSOM의 작업을 먼저 진행하는 것이 좋다.

또한 JS의 경우 DOM 과 CSSOM을 동적으로 변화시킬 수 있는데, HTML문서 파싱 중 `<script>` 요소를 만나는 순간 해당 스크립트가 실행되고 그 전까지 생성된 DOM 까지만 접근할 수 있다.

즉, 스크립트 실행이 완료되기 전까지 DOM 생성이 중지된다는 의미로 DOM 트리의 생성 시간이 늦춰질 뿐만 아니라 해당요소 이후에 생성되는 DOM의 제어가 뜻대로 이뤄지지 않을 수 있다.

### 브라우저 이미지 최적화하기

<aside>
💡 사실 페이지 용량의 대부분은 이미지와 같은 미디어 파일이 차지하기 때문에 이를 최적화하는 것이 속도와 직접적인 연관이 있다.

</aside>

1. 이미지 스프라이트

클라이언트에서의 서버 요청이 증가할수록 로딩시간은 자연스럽게 증가한다. 따라서 이미지를 요청하는 횟수를 줄여 최적화를 진행할 수 있다.

![Untitled](/post-img/optima01.png)

이를 위해 네이버의 경우 여러개의 이미지를 모아 하나의 스프라이트 이미지로 만들고 CSS의 `background-position` 속성을 사용해 이미지의 일정 부분만 사용하고있다.

이로인해 네트워크 로딩시간을 줄이고 이미지의 관리성 향상을 증대할 수 있다.

1. 아이콘 폰트 사용하기

아이콘의 사용이 많을 경우 이를 모두 이미지로 사용하면 그에따른 용량이 증가할 것이다. 따라서 `Font Awesome` 과 같은 아이콘 폰트를 사용해 용량을 최적화할 수 있다.

1. WebP 또는 AVIF 이미지 포맷 사용하기

기존에 사용하던 JPEG, PNG가 아닌 WebP, AVIF를 사용하면 이미지의 용량을 감소할 수 있다. 기존의 포맷과 비교해 20 ~ 50% 이상 용량의 차이가 있지만 아직 이를 지원하는 브라우저가 대부분이다.

이를 위해 개발단계에서 이미지파일을 분기해 대체할 수 있으며 이때 사용되는 Tag가 `<picture>` 이다. 

> `<picture>`
: img 요소의 다중 이미지 리소스(multiple image resources)를 위한 컨테이너를 정의할 때 사용한다.
> 

```html
<picture>
  <source srcset="logo.webp" type="image/webp">
  <img src="logo.png" alt="logo">
</picture>
```

이와 같이 작성할 시 접속한 브라우저가 WebP를 지원하지 않으면 `<source>` 태그는 무시되고 `<img>` 태그가 적용될 것이다. 

### 캐시 사용하기

캐시란 다운받은 데이터나 값을 미리 복사해 놓는 임시장소이며, 캐시를 사용하여 저장된 데이터를 꺼내오면 데이터를 접근하는 시간과 연산시간을 줄일 수 있다.

프론트엔드 단에서 캐시를 사용하기 위해서는 HTTP 요청 시 조건부 요청 헤더를 작성해 캐시의 재사용을 확인해주면된다. 

- `If-Modified-Since` : 캐시된 리소스의 Last-Modified 값 이후에 서버 리소스가 수정되었는지 확인하고, 수정되지 않았다면 캐시된 리소스를 사용합니다.
- `If-None-Match` : 캐시된 리소스의 ETag 값과 현재 서버 리소스의 ETag 값이 같은지 확인하고, 같으면 캐시된 리소스를 사용합니다.

보통 위와 같은 두가지 헤더를 동시에 사용하는데 둘 중 하나라도 매칭이 되어야 리소스를 재사용할 수 있기 때문이다. 

### CDN 사용하기

![Untitled](/post-img/optima02.png)

CDN(Content Delivery Network)은 보다 빠른 콘텐츠 제공을 위해 설계되었으며 세계 곳곳에 서버를 분산하여 유저와 호스팅 서버 간의 물리적 거리를 줄여 네트워크 지연시간을 줄인다.

CDN은 유저가 가까운 곳에 위치한 데이터 센터의 데이터를 가져오며 이로인해 거쳐야하는 서버의 갯수가 줄어 속도를 최적화한다.

## 트리 쉐이킹 (Tree shaking)

<aside>
💡 말 그대로 나무를 흔들어 잔가지를 털어내듯이 불필요한 코드를 털어내는 것을 뜻하며 애플리케이션 규모에 따라 다양한 라이브러리와 방대한 코드로 인해 불필요한 코드를 그대로 가져가는 경우가 빈번하다.

이를 찾아내어 제거하는 트리쉐이킹은 최적화에 큰 효과를 나타낸다.

</aside>

### JS 파일의 크기와 실행시간

<aside>
💡 과거에 비해 페이지의 인터랙션이 많아지면서 JS 코드의 크기와 실행시간이 자연스럽게 비대해졌다. 또한 JS파일의 갯수만큼 네트워크 요청이 비례하게 증가하면서 네트워크 리소스 또한 소모가 커졌다.

아래의 사진은 11년도 대비 웹 애플리케이션의 JS 파일의 크기를 수치화한 것으로 네트워크를 오가는 JS 파일이기에 압축되어 있어 실제 크기는 더 차이날 것으로 예상된다.

또한 요청을 통해 받아온 스크립트의 압축을 푸는 단계부터 컴파일링, 파싱 까지 JS는 다른 리소스에 비해 상대적으로 많은 시간을 잡아먹는다.

</aside>

![Untitled](/post-img/optima03.png)

## 트리쉐이킹 실습

<aside>
💡 webpack V4 이상부터 ES6 모듈(import, export)을 대상으로 기본적인 트리쉐이킹을 제공한다. 트리 쉐이킹을 제공하는 환경에서 효과적으로 수행하는 방법을 알아보자.

</aside>

### 1. 필요한 모듈만 import 하기

```jsx
import React from 'react';
// React 라이브러리 전체 import 

import { useState, useEffect } from 'react'
// 사용할 기능만 import 
```

위처럼 구조분해를 통해 사용할 모듈에 대해서만 호출할 경우 번들 과정에서 사용부분의 코드만을 포함해 트리쉐이킹이 가능해 지지만 전체 라이브러리를 import 할 경우 해당 라이브러리의 모든 모듈이 번들링되어 크기가 거대해진다.

### 2. Babelrc 설정

```jsx
{
  “presets”: [ 
    [
      “@babel/preset-env”,
      {
	    "modules": false
      }
    ]
 ]
}
```

Babel은 JS문법을 구형 브라우저에서도 호환할 수 있게 ES5 문법으로 변환하는 라이브러리로 ES6 의 import 대신 `require` 로 변경시키는데 `require` 는 export 되는 모든 모듈을 불러오기 때문에 import 사용이 무용지물이 될 수 있다. 

따라서 위 코드처럼 `Babelrc` 를 설정해 module 변환을 막아줄 수 있다.

### 3. sideEffect 설정

webpack은 사이드 이펙트를 일으킬 수 있는 코드를 사용하지 않더라도 트리쉐이킹 대상에서 제외시킨다. 외부에 영향을 줄 수 있는 코드의 경우 제외 시 위험하다 판단해 이를 포함시키는데 이럴 때 package.json 파일에서 사이트 이펙트를 설정하여 제외시켜도 됨을 알릴 수 있다.

```jsx
{
  "name": "tree-shaking",
  "version": "1.0.0",
  "sideEffects": false
}

// or

{
  "name": "tree-shaking",
  "version": "1.0.0",
  "sideEffects": ["./src/components/NoSideEffect.js"]
}
```

## Lighthouse

<aside>
💡 lighthouse란 웹 페이지의 품질 개선을 위한 도구로 웹페이지의 성능 을 측정해 개선점을 알려주는 도구이다.

</aside>

![Untitled](/post-img/optima04.png)

개발자 도구의 Lighthouse 탭을 통해 사용할 수 있으며 모바일, 데스크탑 모두 지원한다.
측정 카테고리로 Perfomance, Progressive web app, seo 등의 다양한 지표가 있으며 각 카테고리에 대해 개선점을 알려준다.

### Performance

![Untitled](/post-img/optima05.png)

웹에 대한 성능에 대해 측정하는 부분으로 

1. First Contentful Paint
    - FCP
    - 사용자가 특정 웹 페이지로 이동했을 때, 브라우저가 첫 번째 DOM의 콘텐츠를 렌더링하는 데 걸리는 시간
2. First Meaningful Paint
    - FMP
    - 사용자가 페이지를 불러오기 시작하면서 스크롤을 내리지 않은 채 제일 먼저 볼 수 있는 영역에 존재하는 주요한 콘텐츠를 렌더링하는 데 걸리는 시간
    - Lighthouse 버전 6.0 이후로 사용되지 않는다. (작은 차이에도 매우 민감하게 측정되어 일관성 없는 결과를 초래하였기 때문이다.)
3. Speed Index
    - 웹 페이지를 불러올 때, 콘텐츠가 시각적으로 표시되는 데까지 걸리는 시간
4. First CPU Idle
    - 웹 페이지가 최소한으로 상호작용할 수 있는 상태가 될 때까지 걸리는 시간
    - Lighthouse 버전 6.0 이후로 사용되지 않는다. (Time To Interactive와 측정 기준이 유사했지만 의미 있는 결과값을 보이지 못했다.)
5. Time To Interactive
    - 웹 페이지가 완전히 상호작용할 수 있는 상태가 될 때까지 걸리는 시간
6. Max Potential First Input Delay
    - FID
    - 사용자가 웹 사이트와 처음 상호작용(버튼 클릭)할 때부터 브라우저가 실제로 해당 상호작용에 응답할 수 있을 때까지 걸리는 가장 긴 시간
    - (즉, 최악의 경우를 측정)
7. Total Blocking Time
    - TBT
    - 웹 페이지가 사용자 입력에 응답하지 못하도록 차단된 총 시간
    - = 로딩 중 메인 스레드가 긴 시간동안 중단되어 응답을 받을 수 없을 정도로 걸린 시간
8. Largest Contentful Paint
    - LCP
    - 뷰포트에서 가장 큰 콘텐츠 요소가 화면에 렌더링 될 때까지 걸리는 시간

서술한 건 8개지만 Lighthouse 버전 6.0부터 사용되지 않는 메트릭를 제외하면 총 6개라고 볼 수 있다.그렇지만 이게 전부가 아니다. 여기에서 하나 더 추가된 지표가 있다. 그건 바로 Cumulative Layout Shift(CLS) 메트릭이다.

이외에도 여러 항목이 존재하며 Learnmore를 통해 더 많은 내용을 확인할 수 있다.

### Accessibility

![Untitled](/post-img/optima06.png)

Lighthouse는 웹 애플리케이션의 접근성을 검사한다. <img> 태그에 alt 속성이 있는지, <html> 태그에 lang 속성이 있는지, 배경색과 전경색의 대비가 충분한지와 같은 항목을 확인한다.

### Best Practice

![Untitled](/post-img/optima07.png)

Lighthouse는 웹 페이지가 웹에 대한 표준 모범 사례를 따르고 있는지 확인한다. 

웹 애플리케이션을 가동할 때 콘솔에 오류가 출력되진 않는지, 더는 사용하지 않는 API를 호출하고 있지 않은지, HTTPS를 통해 해당 페이지에 접근할 수 있는지와 같은 항목을 확인한다. 불필요한 코드를 찾아낸다.

### SEO

![Untitled](/post-img/optima08.png)

Lighthouse는 웹 페이지가 검색 엔진에 대해 최적화된 순위 결과를 가지고 있는지 확인한다. 

각 사용자가 자신의 디바이스를 이용하여 웹 페이지에 접근하였을 때 그들이 콘텐츠를 읽는 데에 무리가 없는 글꼴 크기를 사용하는지, 웹 페이지의 robots.txt 파일이 유효한지, 올바른 상태 코드를 사용하는 지와 같은 일부 SEO 모범 사례를 확인한다.

다른 SEO프로그램도 있지만 라이트하우스에서 제공하는 SEO도 유용하다고 판단된다.

### Progressive Web App

![Untitled](/post-img/optima09.png)

Lighthouse는 Progressive Web App을 정의하는 일련의 기준에 따라 웹 페이지를 확인한다. 

이 검사는 해당 웹 페이지가 항목을 따르고 있는지 측정하여 점수를 부여하는 것이 아니라 웹이 HTTP를 HTTPS로 리다이렉션하는지, 응답 코드는 명확한지, 3G 네트워크에서도 로딩이 빠르게 이루어지는 지와 같은 여부를 검사하여 합격 또는 실패를 판별한다.

---
<br><br>
## 마무리

