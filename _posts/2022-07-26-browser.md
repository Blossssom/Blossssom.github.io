---

layout: post

title: 22 / 07 / 24 My TIL [Browser]

subtitle: SEB TIL

categories: coding

tags: [Browser]

---
<aside>
💡 프론트엔드 개발자가 되고 싶으면서 브라우저를 소홀히 다뤘던것 같다 브라우저랑 더 친해져보자.

</aside>

## 브라우저??

매일 빼놓지 않고 브라우저를 사용하고 있지만 브라우저가 어떤 역할을 하고 어떤 의미인지 알지 못했던 것 같다. 

- 브라우저란 월드 와이드 웹(www)에서 정보를 검색, 표현, 탐색하기 위한 소프트 웨어다.
- 기본적으로 주소 입력창과 같은 UI가 있고 서버와 HTTP로 통신하는 네트워크 모듈을 포함한다.
- 웹의 시각적 표현과 기능을 위한 문서를 해석하고 표현하기 위한 해석기(Parser)들을 가지고 있다.

이러한 브라우저는 사용자가 요청하는 페이지, 이미지 등의 자원을 서버에 요청해 전달받아 화면에 출려하여 표현하는 역할을 한다.

## 브라우저의 구조

![Untitled](/post-img/browser-1.png)

브라우저의 구조는 위와 같다. 각 브라우저에 따라 조금씩 다를 수 있지만 기본적인 구조는 동일하게 흘러간다.

이렇게만 보면 각 부분이 어떠한 동작으로 브라우저를 그리고 업데이트 하는지 알 수 없으니 조금 더 깊숙히 파고들어보자.

## 브라우저 엔진(Browser Engine)

브라우저 엔진은 사용자 인터페이스와 렌더링 엔진 사이의 동작을 제어한다. 렌더링 엔진 전에 동작하며 렌더링을 위한 시각표현변환, DOM 자료구조를 구현하며, **브라우저의 비즈니스 로직, 핵심 중추인 중요한 부분이다.**

레이아웃 엔진(Layout Engine)이라고도 부르며, 위에서 설명한 동작이 렌더링 엔진과 매우 밀접해서 브라우저 엔진과 렌더링 엔진을 묶어 표현하는 경우도 많다.

브라우저 엔진은 각 브라우저 마다 전용 엔진을 사용하는데 간단한 표로 살펴본 후 하나씩 파고들어 보는게 좋을듯 하다.

![Untitled](/post-img/browser-2.png)

브라우저의 네트워크 탭에서 쿠키를 확인하거나 요청 body 등을 확인할 때 user-agent에서 본적이 많은데 이제야 의미를 알았다. 반성하자

## 렌더링 엔진(Rendering Engine)

[브라우저와 렌더링 엔진 동작 원리](https://all-young.tistory.com/22)

![Untitled](/post-img/browser-3.png)

렌더링 엔진은 이전 과정에서 전달받은 HTML 문서를 파싱하여 DOM 트리를 구축하는 역할을 한다. 즉, 요청한 콘텐츠(HTML, XML, 문서, 이미지 등) 의 출력(표현)을 담당한다.

DOM 생성과정에서 HTML 문서를 한 줄씩 순차적으로 진행하다가 CSS를 로드하는 태그를 만나면 DOM의 생성을 일시중지하고 CSS파일을 서버에 요청 후 파싱해 DOM, CSSOM을 생성하는 과정을 거친다. 그 결과물로 렌더링을 위한 렌더 트리(Render tree)를 생성한다.

### 렌더링 엔진의 동작과정 예시

![Untitled](/post-img/browser-4.png)

위 설명을 그림으로 보면 좀더 수월하게 이해할 수 있다.

### 렌더 트리

![Untitled](/post-img/browser-5.png)

렌더트리는 DOM 트리가 구축되어 가는동안 생성된다.

렌더링 엔진에 대해서는 더 많은 설명과 과정이 필요하지만 그만큼 내용이 많기 때문에 렌더링 엔진 포스팅에서 더욱 디테일하게 다뤄볼 예정이다.

지금은 브라우저에게 다시 관심을 가져보자

## 통신 (Networking)

말 그대로 HTTP 요청과 같은 네트워크 통신에 사용되는 부분으로 보통 플랫폼의 독립적인 인터페이스 이며, 플랫폼의 하부에서 실행된다.

## 자바스크립트 해석기(JavaScript Interpreter)

생각해보면 HTML 파싱 과정에서 CSS 로더를 만나 렌더트리를 구축하는 것처럼 JS도 반드시 해석되고 실행되어야 한다.

바로 그것을 담당하는 부분이 자바스크립트 엔진이다. 

JS 엔진도 브라우저 엔진처럼 다양한 엔진이 존재하지만 가장 유명한 엔진은 크롬에서 사용되는 V8 엔진이다.

이 부분또한 다뤄야할 내용이 너무많고 깊기 때문에 다른 포스팅에서 독점적으로 다룰 예정이니 아래 참고 블로그를 보며 먼저 익숙해지자

[[ 번역 ] 자바스크립트 시각화 : 자바스크립트 엔진](https://velog.io/@jjunyjjuny/%EB%B2%88%EC%97%AD-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%8B%9C%EA%B0%81%ED%99%94-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%97%94%EC%A7%84)

[자바스크립트 엔진 ?](https://velog.io/@benis/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%97%94%EC%A7%84)

## UI 백엔드

UI 백엔드는 렌더링 엔진이 북석한 렌더트리를 브라우저에 그리는 역할을 담당하며, Select, Input 과 같은 기본적인 위젯을 그린다. 플랫폼에서 명시하지 않은 일반적은 인터페이스로, OS 사용자 인터페이스 체계를 사용한다.

사용자 인터페이스의 경우 우리가 흔히 알고있는 UI / UX의 UI와 조금 다른 것으로 사람과 사물(시스템) 사이에서 의사소통을 지원하는 일시적 혹은 영구적인 접근을 목적으로 만들어진 가상적 매개체를 뜻한다.  

## 자료저장소

이름 그대로 자료의 저장을 담당하는 계층이다. 

쿠키와 같이 모든 자원을 하드에 저장할 필요에 따라 존재하며, HTML5 명세에는 브라우저가 지원하는 웹 저장소(웹 스토리지) 스펙이 정의되어 있다.

영구저장소인 로컬스토리지(Local Storage)와 세션스토리지(Session Storage)를 따로 두어 데이터의 지속성에 따라 구분하여 응용할 수 있다.

### 웹 스토리지

HTML5 이전에서는 응용 프로그램이 서버를 요청할 때마다 쿠키에 정보를 저장했다.

하지만 쿠키 자체의 보안성 취약과 허용 용량의 문제로 대안을 갈구하게 되었고 웹 스토리지가 등장하였다.

위에서 설명했듯이 웹 스토리지는 브라우저가 직접 데이터를 저장할 수 있게하며, 저장된 모든 정보는 절대 서버로 전송되지 않아 기존보다 많은 양의 정보를 안전하게 저장할 수 있다.

또한 클라이언트에만 데이터가 존재하므로 네트워크 트래픽 코스트 또한 줄여준다.

### 로컬스토리지(Local Storage)

로컬스토리지 객체는 기한 없이 데이터를 저장할 수 있으며, 따라서 브라우저 탭이 닫히거나 디바이스를 재부팅 하더라도 데이터가 사라지지 않는다.

Windows 전역객체의 localStorage 컬렉션을 통해 핸들링이 가능하고 도메인 별로 생성된다. 즉, 도메인만 같다면 전역으로 데이터의 공유가 가능해진다. 

### 세션스토리지(Session Storage)

세션스토리지 객체는 하나의 세션만을 위한 데이터를 저장한다.

로컬과 다르게 데이터를 지속적으로 보관하지 않고 현재 브라우징 되고있는 브라우저 컨텍스트 내에서만 데이터가 유지되기 때문에, 브라우저 탭이나 창을 닫으면 데이터가 소실된다.

위에서 나온 브라우저 컨텍스트는 브라우저가 문서를 표시하는 환경을 뜻하며, 각 브라우징 컨텍스트는 특정 출처 및 활성화되고 있는 문서의 출처, 표시했던 모든 문서의 방문 기록을 가지고있다.

세션스토리지 역시 Windows 전역 객체의 sessionStorage 컬렉션을 통해 핸들링하며 도메인 별로 생성되지만 브라우저가 다르면 서로 다른 영역으로 나눠진다는 특징이 있다. 즉, 브라우저 두 개로 같은 페이지를 열어도 브라우저 컨텍스트가 서로 다르기 때문에 sessionStorage 또한 별개의 영역으로 인지되어 공유가 불가능하다.

---
<aside>
블로그 글 작성, 백업 등의 사용자의 편의를 위한 기능에 사용되기도 하고 히스토리 등을 저장하여 활용하기도 한다.

이전에 개인 프로젝트를 구현하며 로그인 정보를 전역 상태로 관리하기 위해 사용을 했었는데 브라우저 내에서 수정 및 삭제가 가능해서 암호화를 거치며 진행한 경험이 있다. 

아직까지 어떠한 방식이 효율적이고 안전한지 알기위해 여러 레퍼런스를 찾아봐야할 것 같다.

</aside>

---
<br><br>
## 마무리

리액트의 virtual dom을 학습하려다 DOM과 브라우저에 대해 정확하게 알고있는가 의문이 들어 다시 학습을 진행하게 되었다.

진도에 비해 꽤나 돌아온것 같지만 지금이라도 확실하게 개념을 잡고갈 수 있다는 점이 다행이라고 생각되고 전체적인 그림은 그려지지만 중간중간 그래서 어떻게 이걸하는데? 라는 생각이들어 더 세밀하게 파고들 필요도 있을것 같다.
