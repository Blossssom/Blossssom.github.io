---

layout: post

title: 문제해결과 접근

subtitle: algoritm

categories: algorithm

tags: [algorithm]

---

# 문제 해결과 접근

들어가기에 앞서 알고리즘이란 대체 무엇일까?
최근엔 유튜브, SNS 상단에 노출되는 과정이나 어떠한 제품의 동작을 알고리즘이라 표현하며 상당히 친숙해진 표현이다. 알고리즘의 의미는 특정 작업을 달성하기 위한 과정 혹은 일련의 단계를 의미할 뿐 어떠한 대상을 가리키는 단어는 아니다.

따라서 개발자는 문제해결을 위해 알고리즘을 반드시 알아야하며 모든 해결과정에 포함되어 있는 단계이다. 

물론 이보다 더 넓은 범위에 알고리즘이 속하겠지만 여기선 코딩테스트 문제와 인터뷰를 위한 알고리즘에 초점을 두고 진행해보자.

개인적으로 알고리즘에 상당히 취약한 편이라고 스스로 생각하지만 개발자가 되기 위해선 이 문제를 넘어서야 한다고 생각한다. 이 단원에서 문제해결을 위한 접근과 이해, 분석을 학습하며 조금씩이라도 나아가야한다.

- 문제의 이해
- 구체적인 예제

## 문제의 이해

기존에 해결했던 문제, 그게 아니더라도 우리는 문제를 마주하면 최우선적으로 문제에 대한 이해가 필요하다.

인터뷰나 실시간 해결처럼 시간적 압박을 받는 경우도 있을 수 있고 변수나 배열을 타이핑하며 진행할 수 있겠지만 보다 먼저해야할 일은 문제에 대한 정확한 이해이다. 문제에 대해 신중하게 질문하고 문제를 조사하며 조금이라도 확실한 그림을 그려가는 것이다.

- 나의 방식대로 다시 생각할 수 있는가?
- 문제가 어떤 입력값을 담고 있는가?
- 어떤 출력값이 나와야 하는가?
- 문제에 대한 충분한 정보가 있는가?
- 중요 데이터에 어떠한 명칭을 지정할 수 있는가?

위는 문제해결에 있어 가장 기본적이면서도 중요한 프로세스이다. 당연히 이보다 많은 생각과 과정을 거치겠지만 문제를 해결하기 위한 첫 단계로 밟는것이 중요하다.

```jsx
// 두 수를 합한 값을 반환하는 함수를 작성하시오.

// 1. 내 방식대로 생각하기
"두 수를 파라미터로 받아 더한값을 return 하는 함수 작성"

// 2. 문제의 입력값
"두 수를 받지만 정수, 부동소수, 문자열, BigInt인지 아무도 모른다. 생각할 수 있는 모든 상황에 대비해 작성하자"

// 3. 문제의 출력값
"입력과 같이 출력이 때에 따라 정수, 문자열 등 어떠한 타입으로 반환되는지 생각하자"

// 4. 문제에 대한 정보
"함수가 받는 arg의 갯수가 정해져있는지, 또 유동적일 경우 반환해야할 값에 대해 파악하자"

// 5. 데이터에 대한 명칭
"
 첫 번째 수 = num1;
 두 번째 수 = num2;
 연산 값 = sum;
"
```

위 예제는 간단한 합을 반환하는 함수에 대한 프로세스이다. 얼핏 너무나 간단하지만 여러 예외상황과 네이밍에 있어 이처럼 간단한 문제에도 여러 과정을 거쳐 생각해야 한다는 것이 보인다.

## 구체적인 예시

문제에 대한 이해과정에서 입력, 출력 값에 대해 여러 예외상황을 이해하는 과정을 거쳤을 것이다. 이러한 예시들은 문제에 대한 이해와 온전성 검사를 제공하므로 작성한 코드가 제대로 작동하는지 판단할 수 있는 기반이된다.

- 간단한 예제로 시작하기
- 보다 복잡한 상황의 예제로 진행하기
- 빈 입력값이 있는 예제 파악하기
- 유효하지 않은 입력값이 있는 예제 파악하기

이처럼 문제를 이해했다면 입력과 출력에 대해 파악하고 가장 간단한 예시부터 진행하며 예외를 처리하는 것이 문제해결의 중요한 프로세스이다.

```jsx
// 문자의 갯수를 반환하는 함수를 작성하시오.

charCount("aaaa") // {a: 4}
charCount("bloxxom") // {b: 1, l: 1, o: 2, x: 2, m: 1}
charCount("Hello every body!") // ?
charCount("") // ?
```

위 처럼 간단한 함수의 결과 값을 예상할 때 여러 상황이 발생할 수 있다. 예를 들어 대문자, 공백, 특수문자를 포함하는가? 빈 값이 들어왔을때 반환 값은 무엇인가? 등 여러 예시에 대해 접근한다면 문제를 해결함에 있어 보다 확실한 방법을 제시할 수 있다. 

## 세부 분석

이제 실제 문제 해결을 수행하며 의사코드를 작성하고 그에 대한 질문과 분석을 시행할 차례이다. 의사코드를 반드시 컴팩트하게 작성하거나 올바른 구문이어야 할 필요는 없다. 다만 자신이 해결할 문제에 대한 프로세스와 인터뷰 시 면접관들과 소통하는 과정에서 반드시 필요하기 때문에 필요한 과정이다.

따라서 우리가 해결할 문제의 해결단계를 명확하게 작성해 명확하지 않은 부분을 파악하고 이해하는 과정이 필요하다.

```jsx
const charCount = (str) => {
	// 입력받은 문자열의 각각 갯수를 Object로 반환 {문자 : 갯수}
	// 대문자일 경우 소문자 변환

	// 반환할 객체 생성
	// 문자열 순회 -> 객체에 할당
		// if 대문자 -> 소문자 변환
		// if 문자 key 존재 -> value + 1;
		// else -> value = 1;
		// 공백, 특수문자 pass
	// 최종 객체 반환
}
```

위 처럼 해결해야할 문제의 단계를 세분화하고 전체 과정을 의사코드로 작성하면 실제 코드를 작성하기 이전에 문제에 대한 뚜렷한 틀이 보인다. 특히 인터뷰의 경우 올바른 값을 반환하지 못하더라도 이러한 문제의 이해와 해결방안이 있다는 점은 강력하게 어필될 수 있다.

## 해결 또는 단순화

만약 모든 작업을 거치고나서도 확신이 들지 않거나 어려운 문제가 남았을 경우에는 단순화가 필요하다.

즉, 문제를 해결할 수 있다면 바로 해결하고 해결할 수 없다면 시간이 많이 소요되는 부분을 넘기고 보다 단순한 부분부터 처리하는 것이 문제를 단계적으로 해결함에 있어 효율적일 것이다.

해결하기 어려운 부분에선 잠시 눈을 돌려 단순하게 해결이 가능한 문제를 해결한 후 다시 접근하는 과정에서 접근하는 방식, 동작의 순서 등 문제를 해결하기 위한 방안이 제시될 수 있기 때문이다. 

개인적으로 문제가 해결되지 않을 때 콘솔을 찍어보며 문제점이 나타나는 패턴, 예외상황을 파악하는데 이 부분을 수행하며 실마리를 얻을 때가 많아 공감되는 내용이다. 

문제를 한번에 해결하려는 방식보다 난이도에 따라 단계적으로 거쳐가며 코드를 작성하면 완벽하지 않아도 전체적인 그림을 볼 수 있는 코드를 완성할 수 있을 것이다.

## 되돌아 보기와 리펙터

문제를 해결하면 희열감과 보상심리에 따라 다른 일을 하고싶겠지만 우리는 단순히 작동하는 코드를 넘어 보다 효율적이고 아름다운 코드로 향상하고자 하는 목표가 있어야한다. 코드를 다시 살펴보고, 더 나은 방식을 생각하는 것이 자신을 발전시키는 최고의 방법일 것이다.

- 결과를 확인할 수 있는가?
- 다른 방식으로 결과를 도출할 수 있는가?
- 한눈에 보고 이해할 수 있는가?
- 결과나 방법을 다른 문제에도 적용할 수 있는가?
- 해결책의 성능을 향상시킬 수 있는가?
- 코드를 향상시킬 방법이 있는가(가독성, 네이밍 등)?
- 다른 사람들은 이 문제를 어떻게 해결했는가?

위 처럼 문제를 해결한 후 자신에게 다시금 질문을 던져보면 보다 나은 방향, 효율적인 방식이 떠오를 수 있고 다른 문제를 직면했을 때 활용할 수 있는 힘이 될 수 있다.

```jsx
function charCount(str) {
	const obj = {};
	for(let i = 0; i < str.length; i++) {
		let char = str[i].toLowerCase();
		if(/[a-z0-9]/.test(char)) {
			if(obj[char] > 0) {
				obj[char]++;
			}else {
				obj[char] = 1;
			}
		}
	}
return obj;
}
```

지금까지 예시로 만든 코드를 완성해보면 위와 같다. 하지만 다시 코드를 되돌아보면 보다 나은 코드를 작성할 수 있지 않을까?

```jsx
function charCount(str) {
	const obj = {};
	for(let char of str) {
		if(isAlphaNumeric(char) {
			char = char.toLowerCase();
			obj[char] = ++obj[char] || 1;
		}
	}
return obj;
}

function isAlphaNumeric(char) {
	let code = char.charCodeAt(0);
	if(!(code > 47 && code < 58) && 
		 !(code > 64 && code < 91) &&
		 !(code > 96 && code < 123)) {
		return false;
	}
return true;
}
```

이처럼 코드를 리펙토링 해보았다. 효율의 극대화를 위해 정규식이 아닌 아스키를 활용한 함수가 추가되어 기존보다 코드가 길어졌지만 효율성, 가독성에선 훨씬 나은 코드가 나올 수 있었다.

다만 개인적으로 정말 거대한 문자열을 처리하거나 하드웨어의 성능을 극한으로 고려해야할 상황이 아니라면 정규식으로 사용하는 것이 더 깔끔하지 않았을까 하는 생각은 든다.

---
<br><br><br>
## 마무리

평소 문제를 해결할 때 한번에 문제를 해결하려다 실패하는 경우가 많아서 그런지 뜨끔하는 부분이 많은 내용이었다. 

습관적으로 단계를 밟아가는 패턴으로 문제를 해결하는 힘을 기를 필요가 있다.


