---

layout: post

title: 22 / 06 / 23 My TIL [재귀]

subtitle: SEB TIL

categories: coding

tags: [algorytm]

---

# 재귀 (recursion)

## 재귀의 개념

재귀의 사전적 의미는 다음과 같다.

> **재귀(再歸)** : 원래의 자리로 되돌아가거나 되돌아옴.
> 

말 그대로 원래의 자리, 상태로 되돌아온다는 의미인데 이 글에선 알고리즘의 관점에서 재귀를 다뤄보도록 하자.

```jsx
const recursion = () => {
	recursion();
}
```

재귀를 코드로 표현하면 위 처럼 자기 자신을 호출하는 형식으로 표현할 수 있다. 이처럼 자기 자신을 호출하는 함수를 재귀함수라고 한다.

재귀함수를 활용하면 반복적인 작업을 해야하는 문제를 보다 간결하게 풀어낼 수 있다.

## 재귀 문제의 해결방법

<aside>
♦️ 자연수로 이뤄진 배열을 입력받아 그 합을 리턴하는 함수를 작성하시오.

</aside>

예를 들어 위와 같은 문제가 주어질 경우 반복으로 해결할 수 있지만 재귀적 방식으로도 해결할 수 있다.

재귀적 방식으로 문제를 해결하기 전에 우선 단계를 나눠 확실하게 이해하고 진행해보자.

> 1. 문제를 작게 나눈다.
2. 1번의 과정을 문제가 더 작아지지 않을 때 까지 반복한다.
3. 가장 작은 단위의 문제를 해결해 전체 문제를 해결한다.
> 

### 1. 문제를 작게 나누기

문제의 예시로 `[1, 2, 3, 4, 5]` 의 합을 구하는 함수를 작성하기 전 어떻게 전 과정을 작게 나눌 수 있을까 생각해보자.

단순하게 전체를 더하는 과정보다 `[2, 3, 4, 5]` , `[3, 4, 5]` 처럼 요소가 줄어든 배열의 합을 구하는 것이 보다 작은 과정일 것이다. 

코드로 살펴보자.

```jsx
arrSum([1, 2, 3, 4, 5]) === 1 + arrSum([2, 3, 4, 5]);
arrSun([2, 3, 4, 5]) === 2 + arrSum([3, 4, 5]);
...
```

### 2. 더 작은 단위로 나누기

1번의 과정을 더는 나눠지지 않을 정도로 반복하면 다음과 같다.

```jsx
...
arrSum([4, 5]) === 4 + arrSum([5]);
arrSum([5]) === 5 + arrSum([]);
```

이처럼 문제를 최소단위로 나누면 재귀의 각 단계에 대한 문제를 해결할 수 있고 이 과정을 재귀로 반복해 최종 결론을 얻을 수 있다.

### 3. 문제 해결하기

```jsx
arrSum([]) === 0; // <-- 문제가 더는 작아지지 않는 순간
// 가장 작은 경우의 해결책을 적용합니다.
arrSum([5]) === 5 + arrSum([]) === 5 + 0 === 5;
arrSum([4, 5]) === 4 + arrSum([5]) === 4 + 5 === 9;
arrSum([3, 4, 5]) === 3 + arrSum([4, 5]) === 3 + 9 === 12;
arrSum([2, 3, 4, 5]) === 2 + arrSum([3, 4, 5]) === 2 + 12 === 14;
arrSum([1, 2, 3, 4, 5]) === 1 + arrSum([2, 3, 4, 5]) === 1 + 14 === 15;
```

위 코드처럼 가장 작은 단위에 도달한 경우 값을 반환하면 해당 과정까지 실행된 재귀들은 역행으로 값을 반환하며 최초의 가장 큰 문제가 누적된 값을 받아 최종 결론을 얻을 수 있다.

```jsx
function arrSum (arr) {
  // 빈 배열을 받았을 때 0을 리턴하는 조건문
  //   --> 가장 작은 문제를 해결하는 코드 & 재귀를 멈추는 코드
  if (arr.length === 0) {
    return 0
  }

  // 배열의 첫 요소 + 나머지 요소가 담긴 배열을 받는 arrSum 함수
  //   --> 재귀(자기 자신을 호출)를 통해 문제를 작게 쪼개나가는 코드
	return arr.shift() + arrSum(arr)
}
```

함수로 작성하면 위와 같이 표현할 수 있다.

## 언제 사용할까?

모든 재귀 솔루션은 반복문으로도 해결이 가능하다. 다만 재귀를 적용할 수 있는 경우 코드의 간결함이 한층 높아진다.  

```jsx
for (let i = 0; i < n; i++) {
    for (let j = 0; j < n; j++) {
        for (let k = 0; k < n; k++) {
            for (let l = 0; l < n; l++) {
                for (let m = 0; m < n; m++) {
                    for (let n = 0; n < n; n++) {
                        for (let o = 0; o < n; o++) {
                            for (let p = 0; p < n; p++) {
                                // do something
                                someFunc(i, j, k, l, m, n, o, p);
                           }
                        }
                    }
                }
            }
        }
    }
 }
```

이와 같이 반복문의 깊이가 무수히 깊어지거나 예측 자체가 어려운 경우에는 재귀를 사용하는 방식이 한눈에 봐도 좋다는 것을 느낄 수 있다. 단, 재귀를 사용하기 전에 Stack이 넘칠 경우와 이외에 다른 방식은 없을지도 깊게 생각하고 실행하자.

---
<br><br>
## 마무리

개인적으로 알고리즘에 두려움이 있는건지 다른 학습보다 알고리즘을 학습할 때 마다 기가 빨려나가는 느낌이다. 간단한 문제는 학습을 진행하며 수월하게 넘어갔지만 조금 변형된 문제를 만날 때 마다 사고가 끝까지 가지 못하는 느낌이었다.

이래서 개발자가 될 수나 있으려나 하는 걱정이 물밀듯이 몰려와서 잠깐 다운되어 있었는데 그 시간에 한번이라도 더 연습해서 익숙해져야한다.

