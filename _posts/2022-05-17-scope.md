---

layout: post

title: 스코프 (Scope)

subtitle: JS Study

categories: coding

tags: [javascript]

---
# 스코프란?

스코프(Scope, 유효범위) 는 자바스크립트를 포함한 모든 프로그래밍 언어의 기본적인 부분이다.
변수, 객체의 선언 위치에 따라 참조 및 사용의 범위가 달라지므로 확실히 알아두고 가야한다.

```jsx
let x = 'global';

function foo() {
	let x = 'function scope';
	console.log(x);
}

foo();
console.log(x)
```

위 코드를 보면 이름이 같은 변수 `x` 가 중복 선언되어있다. 그렇다면 함수내부와 외부 즉, 전역과 지역에서 `x` 를 참조할 때 이름이 중복된 2개의 변수 중 어떤 변수를 참조할까?

**스코프는 참조 대상 식별자(Identifier, 변수, 함수의 이름과 같이 어떤 대상을 다른 대상과 구분하여 식별할 수 있는 유일한 이름)를 찾아내기 위한 규칙이다. Javascript는 이 규칙대로 식별자를 찾는다.**

프로그래밍은 변수를 선언하고 값을 할당하며 변수를 참조하는 기본적인 기능을 제공하여 프로그램의 상태를 관리할 수 있게한다. 변수는 전역 또는 코드 블록(if, for, while, try / catch 등) 이나 함수 내에 선언하며, 코드 블록이나 함수는 중첩이 가능하다.

이러한 식별자는 자신이 어디에 선언됐는지에 따라 자신이 유효한(다른 코드가 자신을 참조할 수 있는) 범위를 갖는다.

위 코드 예제에서 함수 밖 즉, 전역에 선언된 `x` 는 어디에서든 참조할 수 있다. 하지만 함수 내부에 선언된 `x` 는 foo 함수 내부에서만 참조할 수 있고 외부에서는 참조할 수 없다. 이러한 규칙을 스코프(scope)라고 한다.

스코프가 없는 프로그램은 디렉토리가 없는 컴퓨터라고 생각하면 쉽다. 하나의 파일명을 컴퓨터 전체에서 하나만 사용할 수 있다고 생각하면 여러 프로그램을 설치하고 실행할 때 마다 엄청난 충돌을 일으킬 것이다.

## 스코프의 구분

Javascript 에서 스코프를 구분해 보면 다음과 같이 2가지로 나눌 수 있다.

- **전역스코프 (Global Scope)**
    - 코드 어디에서든 참조할 수 있다.
- **지역스코프 (Local Scope or Function-level Scope)**
    - 함수 혹은 코드 블록 자체로 만든 스코프로 해당 스코프 자신과 하위 스코프에서만 참조할 수 있다.
    

모든 변수는 스코프를 가진다. 변수의 관점에서 스코프를 구분하면 다음과 같이 2가지로 나눌 수 있다.

- **전역변수 (Global Variable)**
    - 전역에서 선언된 변수이며 어디에서든 참조할 수 있다.
- **지역변수 (Local Variable)**
    - 지역(블록) 내에서 선언된 변수이며, 그 지역과 하위 지역에서만 참조가 가능하다.
    

**변수는 선언위치(전역 또는 지역)에 의해 스코프를 가지게 된다. 즉, 전역에서 선언된 변수는 전역 스코프를 갖는 전역 변수이고, 지역(Javascript의 경우 함수, 블록 내부)에서 선언된 변수는 지역 스코프를 가지게 되어 지역 변수가 된다.**

이러한 변수 또한 스코프에 따라서 참조할 수 있는 범위가 달라지게된다.

## 자바스크립트 스코프의 특징

Javascript의 스코프는 타 언어와 조금은 다른 특징을 가지고 있다.

대부분의 언어의 경우 블록 레벨 스코프(Block-level scope)를 가진다. 블록 레벨 스코프란 코드 블록 `{}` 내에서 유효한 스코프를 가지는데 여기서 유효하다는 말은 참조, 접근이 가능하다는 의미이다.

```c
int main(void) {
  // block-level scope
  if (1) {
    int x = 5;
    printf("x = %d\n", x);
  }

  printf("x = %d\n", x); // use of undeclared identifier 'x'

  return 0;
}
```

위 코드처럼 C언어는 `if` 문 내에서 선언된 변수 `x` 는 선언된 지역인 if 문 내에서만 유효하다.

하지만 자바스크립트는 **함수 레벨 스코프(function-level scope)** 를 따른다. 함수 레벨 스코프란 함수 코드 블록 내에서 선언된 변수는 함수 블록 내에서만 유효하고 외부에서는 유효하지 않다는 뜻이다.

 

```jsx
var x = 0;
{
  var x = 1;
  console.log(x); // 1
}
console.log(x);   // 1

let y = 0;
{
  let y = 1;
  console.log(y); // 1
}
console.log(y);   // 0
```

그런데 이 글의 위에서 설명할 때 자바스크립트의 스코프는 코드블록 자체도 지역으로 보며 블록 레벨 스코프 처럼 동작한다고 하지 않았나?

사실 ECMA Script 6 에서 도입된 `let` keyword를 사용하면 블록레벨 스코프를 사용할 수 있기 때문이다. let이 도입된 이후 호이스팅, 스코프 범위로 인해 사실상 `var` 의 사용 자체를 지양하기 때문에 var를 사용한 변수는 블록레벨을 가졌었다 라고 알아두기만 하면 좋을 것 같다.

## 전역 스코프 (Global Scope)

전역에 변수를 선언하면 이 변수는 어디서든 참조할 수 있는 전역 스코프를 갖는 전역변수가 된다.

특히 `var` 로 선언한 변수의 경우 전역 객체(Global Object) `window` 의 프로퍼티이다. 

```jsx
var varNum = 1023;
console.log(window.varNum);  // 1023

let letNum = 3938;
console.log(window.letNum);  // undefined
```

하지만 위에서 설명했듯이 최근엔 `let` 의 사용을 지향하고 있는데 `let` 의 경우 `var` 와 달리 window 객체와 연결되지 않는다. 따라서 `let` 을 사용할 경우 window 객체에서 변수 혹은 함수를 불러올 수 없다.

자바스크립트는 C 계열 등의 언어와 달리 특별한 시작점이 없다. 예를 들어 C, JAVA를 보면 해당 프로그램을 실행시키는 main 함수가 필수적으로 있어 전역변수와 지역변수의 구분이 뚜렷하지만 자바스크립트의 경우 코드가 나타나면 즉시 해석하고 실행한다. 

이러한 부분은 편리하지만 전역변수를 남발하는 문제를 야기시킨다.

**전역변수는 변수의 이름 중복과 의도치 않은 재할당 등 코드의 상태를 예측하기 어렵게 하므로 사용을 억제해야한다.**

## 렉시컬 스코프

자바스크립트를 비롯한 대부분의 언어는 렉시컬 스코프를 따르고 있다.

렉시컬 스코프란 함수가 선언되는 위치에 따라서 상위 스코프가 결정되는 스코프이다. **함수가 호출될 때가 아닌 함수가 선언될 때라는 것을 정확하게 기억하자.**

```jsx
let x = 'global'

function foo(){
  let x ='local'
  bar()
}

function bar(){
  console.log(x)
}

foo() //global
bar() //global
```

위 예제를 보면 `foo()` 내부에서 `bar()` 함수가 호출됨 에도 전역변수 `x` 를 출력하는 것을 볼 수 있다. 이처럼 해당 함수가 호출되는 지역에 지역 변수를 선언했음 에도 선언 당시의 상위 스코프인 전역 스코프에서 변수를 참조한다.

```jsx
let funcArr =[]

for(let i = 0; i < 5; i++) {
 let c = i *2;
 funcArr.push( function inner() {console.log(c)})
}

funcArr.forEach( fn => fn() )

// 0
// 2
// 4
// 6
// 8
```

이번엔 반복을 거쳐 배열 내부에 함수를 선언하여 추가하는 코드이다. 어찌보면 결과가 당연하다고 볼 수 있지만 반문 블록에서 선언된 `c` 변수가 함수가 호출되지 않았음에도 저장되어 있는 것을 볼 수 있다.

`ES6` 에서는 블럭이 생성되면서도 실행컨텍스트가 실행된다. 실행 컨텍스트가 생성되면서 당연히 lexical environment도 생성된다.

이때 선언되고 push 되는 `() => { console.log(c) }` 함수는 블럭의 실행 컨텍스트에서 선언되기 때문에 그 때의 변수 `c` 값을 참조하게 된다. 그리고 각각 `c` 값을 참조하는 `() => { console.log(c) }` 함수를 funcArr에 push를 한다.

![](/post-img/scope01.png)

위 처럼 funcArr을 자세히 뜯어보면 함수들이 각각의 스코프를 가지는 것을 볼 수 있다.

## 즉시실행함수를 이용한 전역변수 사용 억제

전역변수 사용을 억제하기 위해 즉시실행함수(IIFE, Immediately-Invoked Function Expression)를 사용할 수 있다. 이 방법을 사용하면 전역변수를 만들지 않으므로 라이브러리 등에 자주 사용된다.

즉시 실행 함수는 즉시 사용되며 그 후 바로 전역에서 사라진다.

```jsx
(function () {
  let MYAPP = {};

  MYAPP.student = {
    name: 'Lee',
    gender: 'male'
  };

  console.log(MYAPP.student.name);
}());

console.log(MYAPP.student.name);
```
---


## 마무리

당연하게 사용하던 느낌이었는데 막상 예제들을 실행해보니 예측과 다른 결과가 나오는 경우도 있었다.

스코프의 실행 동작이나 컨텍스트, 이후 클로저를 이해하기 위해 이부분은 확실하게 이해하고 넘어가야한다.

<br><br><br>

## 참고 사이트
- [제로초 Blog](https://www.zerocho.com/category/JavaScript/post/5af6f9e707d77a001bb579d2)
