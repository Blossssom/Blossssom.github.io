---

layout: post

title: 객체와 배열의 Big O

subtitle: Udemy class

categories: algorithm

tags: [javascript, algorithm]

---
# 객체와 배열의 Big O

이번엔 객체와 배열로 가장 빠르게 처리할 수 있는게 뭘까? 생각보다 느린 메소드는 뭘까? 와 같이 빅오 시점에서의 Object와 배열이 어떻게 동작하는지를 알아보자.

예를 들어 배열에 데이터를 입력함에 있어 더 나은 방법이 무엇인지, 왜 배열 앞에 데이터를 추가하는 것이 좋지 않은지 등 자바스크립트를 사용함에 있어 보다 나은 방법과 대안을 알아보는 시간이 될 듯하다.

단, 무작정 외우기가 아닌 배열과 객체를 사용함에 있어 Big O 표기법을 가지고 이해할 수 있는지에 초점을 두고 시작하자.

## 객체의 Big O

```jsx
const rifle = {
	name: 'mp5',
	bullet: '9mm'
}
```

기본적으로 Object는 위 처럼 key와 value를 가지고 있으며 이러한 객체는 다음과 같은 경우 사용하면 효율적이다.
<br>
- 정렬이 필요없을 때
- 빠른 접근, 입력 및 제거를 원할 때
<br>

객체는 key를 가지고 있어 어떠한 값을 접근하고 다루는데 있어 순회가 필요없고, 이로 인해 O(1)이라는 상수 시간을 갖는다.

또한 객체는 시작과 끝의 개념이 없기에 어디에 입력하든 성능이나 객체 자체에 영향을 주지 않는다. 물론 더 깊게 들어가면 Hash와 Map의 개념을 필요로 하기 때문에 추후 실컷 알아볼 수 있을 것이다.
<br>
- Insertion - O(1)
- Removal - O(1)
- Searching - O(N)
- Access - O(1)

<br>
위에서 말했듯 접근, 입력, 제거는 상수시간이지만 탐색의 경우는 선형시간을 갖는다. 접근과 탐색이 얼핏 비슷하게 들리지만 여기서 말하는 탐색은 실제 값이 어디에 담겨있는가를 의미하기에 key를 사용해 값을 꺼내오기 전 잠재적으로 모든 요소의 속성을 확인해야하기 때문이다.

## 객체 메소드의 Big O

이번엔 객체의 메소드에 대한 시간 복잡도를 알아보자.
<br>
- Object.keys - O(N)
- Object.values - O(N)
- Object.entries - O(N)
- hasOwnProperty - O(1)

<br>
keys, values 등의 각 요소에 접근해 반환하는 메소드는 당연히 선형시간을 갖는다.

그런데 요소의 포함 여부를 판단하는 hasOwnProperty의 경우 상수시간을 갖는데 이에 대해 한번 생각해보자. 

객체 자체의 Big O에서 접근에 대한 시간은 상수시간이었다. 그렇기 때문에 똑같은 시간 내에 key가 존재하는지에 대한 여부를 상수시간으로 판단할 수 있는 것이다.

---

## 배열의 Big O

모든 프로그램의 근본, 구조 그 자체인 배열과 그 메소드의 복잡도를 알아보고, 객체와 비교했을 때 성능이 어떠한지도 파악해보자.
<br>
```jsx
const music = ['jazz', 'rock', 'funky'];
const data = [true, {}, [], 2, 'any'];
```
<br>
우선 배열은 위와 같은 구조를 가진다. 프로그램 마다 조금씩 다르지만 기본적으로 “배열” 이라는 것은 같은 타입의 자료형을 가지고, 리스트와 차이가 있다고 알고 있는데 자바스크립트의 경우 어떠한지 좀 더 알아볼 필요가 있을 듯 하다.

배열은 정렬이 되어있다. 숫자의 정렬, 문자의 순서 등을 떠나 데이터가 정렬되는 자체의 기준을 뜻하는 것이다. 이는 객체와 배열의 가장 큰 차이이기도 하다.

이러한 특징은 상황마다 유용할 수 있지만 연산 과정에서 시간이 더 걸릴 수 있다. 배열을 사용해 보았다면 인덱스가 존재한다는 것도 알테니 그 부분은 호다닥 넘어가보자.

배열은 다음과 같을 때 사용하면 효율적이다.
<br>
- 정렬된 데이터가 필요할 때
- 빠른 접근, 입력, 제거를 원할 때

<br>
정렬된 데이터가 필요없다면 당연히 배열을 사용할 이유가 없을 것이고, 단지 여러 타입의 데이터를 저장하고 싶다면 배열 외에도 선택지가 많을 것이다.

성능의 최적화를 원한다면 이후 학습할 linked list 등을 사용할 수 있지만 어디까지나 상황에 따라 다르기 때문에 하나씩 짚고 넘어가보자.
<br>
- Insertion - depends…
- Removal - depends…
- Searching - O(N)
- Access - O(1)
<br>

우선 배열의 기본적인 복잡도는 위와 같다.

배열은 key를 가지진 않지만 엄연히 index를 가지고 있어 이를 이용한 접근은 물론 O(1)로 상수시간을 가진다.

그런데 입력과 제거의 경우 조금 이상하게 표시를 해두었는데 이는 배열의 어느 위치에 입력, 제거를 실행하는가에 따라 다르기 때문이다.

---

객체의 경우 시작과 끝이 없기에 위치라는 개념을 가지지 않지만 배열의 경우 다르기 때문인데, 배열의 끝에 추가, 제거를 할 경우 작업시간은 O(1)로 배열의 맨 끝에서의 작업은 객체에 추가하는 것 처럼 값과 인덱스만을 추가하기 때문이다.

하지만 배열의 앞에 추가하는 경우는 이야기가 다르다.

배열의 인덱스는 0부터 시작하는 것을 알고 있을 것이다. 그런데 배열의 앞에 값을 추가하면 인덱스는 어떻게 되는지 생각해 보았는가? 

배열의 앞에 추가할 경우 인덱스를 밀어가며 새로 배정해야하기 때문에 O(N)의 선형시간을 갖는 것이다. 이와 같이 배열의 앞을 제거할 경우 다시 인덱스를 당겨서 배정해야하기에 이 또한 선형시간을 가질 것이다.

따라서 배열의 상태 (비어 있을 때 등)에 따라 다를 수 있지만 push와 pop이 shift와 unshift 작업보다 빠른 시간을 갖는다.
<br>
 

## 배열 메소드의 Big O

배열의 기본적인 메소드 들은 다음과 같은 시간을 갖는다.
<br>
- push - O(1)
- pop - O(1)
- shift - O(N)
- unshift - O(N)
- concat - O(N)
- slice - O(N)
- splice - O(N)
- sort - O(N * log N)
- forEach / map / reduce /filter … - O(N)
<br>

배열의 맨 끝에 대한 입력과 제거 메소드의 경우 당연히 O(1)일 것이고 sort는 예상한 대로 오래 걸리는 것을 볼 수 있다. 다만 고차함수의 경우 다른 글에서 보니 log 시간을 가진다는 말도 있는데 확실한 정보를 확인하면 다시 정리해 보자.

또한 concat의 경우 두 배열의 합이라 시간이 더 걸릴줄 알았는데 실제 두 배열의 값을 적용하기에 O(N + M)으로 동작하지만 그래도 결국 두 배열의 길이만큼만 늘어나기에 O(N)으로 보면된다.

splice의 경우 추가, 삭제, 변경이 모두 가능하고 배열의 끝에서도 작업을 할 수 있지만 특정 상황이기에 일반적으로 O(N)으로 본다.

sort는 정렬에 대한 알고리즘이 워낙 많고 각각의 시간복잡도는 다르겠지만 단지 요소에 탐색, 접근 만으로는 충분하지 않기에 O(N) 보다는 더 큰 시간 복잡도를 가진다.

## 정리

### 객체 (Object)

- 모든 것이 배열보다 빠른편
- 정렬이 되어있지 않음

### 배열 (Array)

- 정렬되어 있어 특정 상황에 빠름
- 끝에 추가하는 것은 빠르지만 시작, 중간 지점은 인덱스로 인해 느림

---

<br><br><br>

## 마무리
알고리즘이 워낙 약점이기도 하고 개념적인 내용을 이해할 수 있을까했지만 가려운 곳을 살살 긁어주는 듯이 속시원한 시간이었다.

문제를 풀면서도 어떤걸 써야하나 싶을 때가 많았고, 물론 지금도 그렇지만 이제는 조금씩 판단을 할 수 있을만한 이론이 생긴것 같아 만족스럽다.

꾸준히 학습하면서 실제 문제풀이에도 바로바로 적용할 수 있도록 노력하자.




## 참고 사이트
- [Udemy JavaScript 알고리즘 & 자료구조 마스터클래스](https://www.udemy.com/course/best-javascript-data-structures/)
